import Foundation
import TuistCore
import TuistGraph

/// Mapper that generates a new scheme `ProjectName-Project` that includes all targets
/// From a given workspace
public final class AutogeneratedProjectSchemeWorkspaceMapper: WorkspaceMapping { // swiftlint:disable:this type_name
    private let codeCoverageMode: CodeCoverageMode?

    // MARK: - Init

    public init(codeCoverageMode: CodeCoverageMode?) {
        self.codeCoverageMode = codeCoverageMode
    }

    public func map(workspace: WorkspaceWithProjects) throws -> (WorkspaceWithProjects, [SideEffectDescriptor]) {
        guard let project = workspace.projects.first else { return (workspace, []) }

        let platforms = Set(
            workspace.projects
                .flatMap {
                    $0.targets.map(\.platform)
                }
        )

        let schemes: [Scheme]

        if platforms.count == 1, let platform = platforms.first {
            schemes = [
                scheme(
                    name: "\(workspace.workspace.name)-Project",
                    platform: platform,
                    project: project,
                    workspace: workspace
                ),
            ]
        } else {
            schemes = platforms.map { platform in
                scheme(
                    name: "\(workspace.workspace.name)-Project-\(platform.caseValue)",
                    platform: platform,
                    project: project,
                    workspace: workspace
                )
            }
        }

        var workspace = workspace
        workspace.workspace.schemes.append(contentsOf: schemes)
        return (workspace, [])
    }

    // MAARK: - Helpers

    private func scheme(
        name: String,
        platform: Platform,
        project: Project,
        workspace: WorkspaceWithProjects
    ) -> Scheme {
        var (targets, testableTargets): ([TargetReference], [TestableTarget]) = workspace.projects
            .reduce(([], [])) { result, project in
                let targets = project.targets
                    .filter { $0.platform == platform }
                    .map { TargetReference(projectPath: project.path, name: $0.name) }
                let testableTargets = project.targets
                    .filter { $0.platform == platform }
                    .filter(\.product.testsBundle)
                    .map { TargetReference(projectPath: project.path, name: $0.name) }
                    .map { TestableTarget(target: $0) }

                return (result.0 + targets, result.1 + testableTargets)
            }

        targets = targets.sorted(by: { $0.name < $1.name })
        testableTargets = testableTargets.sorted(by: { $0.target.name < $1.target.name })

        let coverageSettings = codeCoverageSettings(workspace: workspace)

        return Scheme(
            name: name,
            shared: true,
            buildAction: BuildAction(targets: targets),
            testAction: TestAction(
                targets: testableTargets,
                arguments: nil,
                configurationName: project.defaultDebugBuildConfigurationName,
                coverage: coverageSettings.isEnabled,
                codeCoverageTargets: coverageSettings.targets,
                expandVariableFromTarget: nil,
                preActions: [],
                postActions: [],
                diagnosticsOptions: [.mainThreadChecker]
            )
        )
    }

    private func codeCoverageSettings(workspace: WorkspaceWithProjects) -> (isEnabled: Bool, targets: [TargetReference]) {
        switch codeCoverageMode {
        case .all: return (true, [])
        case .none: return (false, [])
        case let .targets(targets): return (true, targets)
        case .relevant:
            let allSchemes = workspace.workspace.schemes + workspace.projects.flatMap(\.schemes)
            var resultTargets = Set<TargetReference>()

            allSchemes.forEach { scheme in
                // try to add code coverage targets only if code coverage is enabled
                guard let testAction = scheme.testAction, testAction.coverage else { return }

                let schemeCoverageTargets = testAction.codeCoverageTargets

                // having empty `codeCoverageTargets` means that we should gather code coverage for all build targets
                if schemeCoverageTargets.isEmpty, let buildAction = scheme.buildAction {
                    resultTargets.formUnion(buildAction.targets)
                } else {
                    resultTargets.formUnion(schemeCoverageTargets)
                }
            }

            // if we find no schemes that gather code coverage data, there are no relevant targets,
            // so we disable code coverage
            if resultTargets.isEmpty {
                return (false, [])
            }

            return (true, Array(resultTargets))
        }
    }
}
